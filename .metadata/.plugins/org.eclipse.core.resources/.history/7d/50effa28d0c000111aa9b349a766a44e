//DO NOT MODIFY  Computed Data Items Processor|LNCO|||||||1
LNCO	// Computed Data Items Processor
	/*
	   ORIG:  Chuck Hardy (6721) - 02/25/86
	

	---- Revision History ------------------------------------------------
	
	06/11/10 - Rachod Intraha
		   Modified TSOREC to quit if loan record doesn't exists.
	
	05/22/09 - Savitha Venkatesh - CR 39499
		   Modified the section TSOESCT to refer to the correct field
		   PCFL11 for checking whether the transaction code affects
		   escrow remittance.
		   
	04/21/09 - Brent Condie 
		   Matched changes from Profile_V73 - CR 39122
		   Modified EBBAL section to resolve the undefined error for X.
		   Replaced the variable X with the correct variable of PAYREM.

	04/03/09 - Andrew Sanchez
		   Custom KTB AVLBAL section updated to read
		   if XDAT<%SystemDate set AVLBAL=0 quit

	09/18/08 - Clayton Schwartz - CR 35706
		   Removed the Over Tolerance Limit Percentage (LN.OLTP) amount
		   from the available balance calculation performed in the
		   LNAVLBAL label. This prevents exposing the internal over
		   limit amount on customer facing items (UI, statements
		   etc.).

	02/04/08 - Russ Coryell - CR 31690
		   Modified the LS1 section to add the 11th piece to the 
		   XLN10 string. This 11th piece will be the date the loan
		   was first sold to an investor and it will be stored in 
		   the new column FSDT.

	11/27/07 - KumarB - CR 30273
		   Modified LNAVLBAL to check if ln.ddra is defined prior to 
		   using it to determine if the available balance of a loan
		   should be calculated as zero.  This change is being made in
		   conjunction with the removal of the default value of "30" 
		   previously defined in PRODDFTL.DDRA (e.g., advances should
		   not be restricted if LN.DDRA is null).
		   
	07/31/06 - KELLYP - CR 22048
		   Modified EBBAL section to eliminate PRECEDENCE warning.

	05/18/06 - GIRIDHAL - CR 21297
		   Removed references to Split Day Processing
		   
	04/06/06 - SWARNALP - CR 20388
		   Modified PNTSPY section to remove TJD from the signature of the 
		   function PNTSPY and modified PNTSPY2 section to replace TJD 
		   with %SystemDate to be passed as parameter to the extrinsic 
		   function BOTY^SCADAT.
		   
	03/02/06 - TITOVE - CR 19733
		   Modified TSOPE section to instantiate an LNFEEP object with
		   a "create-if-needed" qualifier.

	02-28-06 - Teliv - CR 19797
		   Modified section LNAVLBAL to recalculate ln.avlbal on the basis of 
		   ln.wdlmt

	09/28/05 - Vince Arpa - CR 17327
		   In LNAVLBAL section, replacing variable TJD and set from
		   cuvar.tjd with variable %SystemDate.  Also cleaned up section to 
		   conform to PSL standards.
		   
	01/13/04 - Erik Scheetz - CR7798
		   Modified TSOAOI section and removed LNCYC reference 
		   (obsoleted) and replace with LNCYCDLD, LNCYCINS,
		   LNCYCMSC and LNCYCPTS.	
	
	12/09/04 - CARROLLJ - CR7239
		   Corrected undefined error in EBBAL section.

	08/25/03 - CARROLLJ - 51630
		   Correct null subscript error in TSOPE section when looking
		   for payment elements from bill.

	08/18/03 - CARROLLJ - 51630
		   Modified TSOPE section to remove two parameters being passed
		   to LNKFEE^LNBLDE.

	07/25/03 - CARROLLJ - 51349
		   Added CID to the call to XLN29^LNCO3 and removed old
		   revision history. 

	10/06/02 - Dan Russell - 49794
		   Modified call to ^UHLD to new syntax.

	*/

	quit

public LS(CID)	// 

	/* The function is used to compute the data item LN.XLN10,
	loan sale amount.

	Arguments:
 
	. CID	Customer Account Number			/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. XLN10	Loan Sale Amount			/TYP=$
 
	Example:
 
	W $$LS^LNCO(123)
 
	*/


	new BALCMP,D,FRE,ND,PP,%ICM
	set XLN10=""
	type RecordLN ln=Db.getRecord("LN","CID")
	
	set BALCMP=ln.bal 
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	set $P(XLN10,"|",3)=100 
	set $P(XLN10,"|",4)=BALCMP
	if 'ln.pflg quit 
	set IRN=ln.irn/100
	set D=""
	
	type ResultSet rs=Db.select("INCD,PL,OPTR,CCID","LNLS6","CID=:CID AND PSEQ>0")
	while rs.next() do { quit:ER
		set INCD=rs.getCol(1)
		set PL=rs.getCol(2)
		set OPTR=rs.getCol(3)
		set CCID=rs.getCol(4)
		do LS1(.ln,INCD,PL,OPTR,CCID)
		}
	set $P(XLN10,"|",2)=$$^SCARND($P(XLN10,"|",2),0,$G(CID))
	set $P(XLN10,"|",3)=100-$P(XLN10,"|",1)
	set $P(XLN10,"|",4)=BALCMP-$P(XLN10,"|",2)
	set $P(XLN10,"|",7)=$$^SCARND($P(XLN10,"|",7),0,$G(CID))
	set $P(XLN10,"|",9)=$P(XLN10,"|",7)+$P(XLN10,"|",8)
	quit 
	
LS1(RecordLN ln,INCD,PL,OPTR,CCID)	//

	new FRE,JD,LN1BAL,ND,PP,YLD,%ICM,%PCM
	
	/*
		INCD = INVESTOR
		PL = POOL_ID
		OPTR = OVERRIDE PASS-THRU RATE
	*/
	
	set OPTR=OPTR/100
	set LN1BAL=0
	if Db.isDefined("LNLS2","INCD,PL") do {
		type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD,PL")

		set $P(XLN10,"|",10)=$P(XLN10,"|",10)+1
		set $P(XLN10,"|",1)=$P(XLN10,"|",1)+lnls2.pp
		if 'D do {
			set $P(XLN10,"|",5)=INCD 
			set $P(XLN10,"|",6)=PL
			set D=1
			}
		
		type ResultSet rs = Db.select("SDAT","LNLS6","CID = :ln.cid","PSEQ ASC")
		if rs.next() set XLN10.piece("|",11) = rs.getCol("SDAT")
		
		set FRE=lnls2.feep
		set PP=lnls2.pp
		set YLD=lnls2.yield/100
		set %ICM=lnls2.picm 
		if '%ICM quit
		type RecordSTBLLSRCM srcm=Db.getRecord("STBLLSRCM","%ICM")
		set DESC=srcm.desc
		set %PCM=$E(DESC,1,2) 
		set %ICM=$E(DESC,3,4)
		set PSEQ=INCD
		if (%PCM="06") do {
			type RecordLN ln1=Db.getRecord("LN","CCID")
			set LN1BAL=ln1.bal
			}
		
		set $P(XLN10,"|",7)=(ln.acr*PP)+$P(XLN10,"|",7)
		set $P(XLN10,"|",2)=$P(XLN10,"|",2)+$S(%PCM="06":LN1BAL,1:BALCMP*PP/100)					
		}
	quit
	
U(CID)	// 
	/* The function is used to compute the data item LN.XLN06,
	Current and uncollected amounts.

	Arguments:
 
	. CID	Customer Account Number			/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. XLN06	Current and uncollected amounts		/TYP=$
 
	Example:
 
	W $$U^LNCO(123)
 
	*/
	set XLN06="" 
	new CUIN2,UNIN2,CUPR2,UNPR2,XLN29
	
	type RecordLN ln=Db.getRecord("LN","CID")
	if ln.stat=4 quit 
	
	set (CUIN2,UNIN2,CUPR2,UNPR2)=0 
	set SCHSEQ=ln.schseq

	if ln.idp do {
		// CURDUE - current due  ESCDUE - tot esc due
		set ESCDUE=ln.cues+ln.unes
		if Db.isDefined("LNBIL1","CID,SCHSEQ") do {
			type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID,SCHSEQ")
			set CURDUE=lnbil1.casd
			}
		else  set CURDUE=0
		if ln.iam do {
			set CUPR2=CURDUE-ln.cues
			set UNPR2=ln.tdue-CUPR2-ESCDUE 
			}
		if ln.tdue<0 set CUPR2=ln.tdue-ESCDUE quit
		set CUIN2=CURDUE-ln.cues 
		if CUIN2>ln.acr do {
			set CUIN2=+ln.acr
			set CUPR2=CURDUE-ln.cues-CUIN2
			}
		if +ln.acr>CUIN2 set UNIN2=+ln.acr-CUIN2

		set UNPR2=ln.tdue-ESCDUE-UNIN2-CUIN2-CUPR2 
		if UNPR2>0 quit

		set UNIN2=UNIN2+UNPR2 
		set UNPR2=0 
		if UNIN2>0 quit
		set CUPR2=CUPR2+UNIN2 
		if CUPR2>0 quit
		set CUIN2=CUIN2+CUPR2
		}
	
	// Interest determined at billing
	if 'ln.idp do {
		set CUIN2=ln.cuin 
		set UNIN2=ln.unin
		set CUPR2=ln.cupr 
		set UNPR2=ln.unpr
		}	

	do XLN29^LNCO3(.ln,CID)
	set XLN06=CUIN2_"|"_UNIN2_"|"_CUPR2_"|"_UNPR2_"|"
	set XLN06=XLN06_(CUIN2+CUPR2+ln.cues+$P(XLN29,"|",5))_"|"
	set XLN06=XLN06_(ln.unes+ln.cues)_"|"_(CUIN2+UNIN2)_"|"_(CUPR2+UNPR2)_"|"
	set XLN06=XLN06_(UNIN2+UNPR2+ln.unes+$P(XLN29,"|",4))_"|"_ln.cues_"|"_ln.unes
	quit 
	

DLBTPC(CID) //
	/*
	Delinquency Loan Balances by Time Period Calculation
		Arguments:
 
	. CID	Customer Account Number			/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. XLN07	Delinquent Loan Balances		/TYP=$
 
	Example:
 
	W $$DLBTPC^LNCO(123)
	*/

	new DCC,DDATE,DPTO,dtlarr,N,PER,pmtarr,TYPE,X
	
	set ER=$$VIEW^PROCLNBL(CID,,.pmtarr,.dtlarr,,2) quit:ER 
	
	type RecordLN ln=Db.getRecord("LN","CID")
	set TYPE=ln.type

	for I=1:1:7 set DCC(I)=""
	//Load Delinquency counter
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	set CLS=prodctl.cls
	set GRP=prodctl.grp
	if prodctl.dcc1'="" set DCC(1)=prodctl.dcc1
	if prodctl.dcc2'="" set DCC(2)=prodctl.dcc2
	if prodctl.dcc3'="" set DCC(3)=prodctl.dcc3
	if prodctl.dcc4'="" set DCC(4)=prodctl.dcc4
	if prodctl.dcc5'="" set DCC(5)=prodctl.dcc5
	if prodctl.dcc6'="" set DCC(6)=prodctl.dcc6
	if prodctl.dcc7'="" set DCC(7)=prodctl.dcc7

	//Initialize all elements in every delinquent period to zero
	for I=1:1:7 do {
		set XLN07(I)="0|0|0|0"
		set DPTO(I)=0
		}
	
	//Read payment array
	set DDATE=""
	for  set DDATE=$O(pmtarr(DDATE)) quit:DDATE=""  do {
		//Set total amount of unpaid bill
		set DPTO=$P(pmtarr(DDATE),"|",1)
		//Is this loan delinquent
		if %SystemDate-DDATE<DCC(1) quit 
		//Determine delinquent period
		for I=7:-1:1 if DCC(I),(%SystemDate-DDATE'<DCC(I)) set PER=I quit 
		//Set total amount of unpaid bills for a delinquent period
		set DPTO(PER)=DPTO(PER)+DPTO
		//Read payment detail array
		set N=""
		for  set N=$O(dtlarr(DDATE,N)) quit:N=""  do {
			//set new X
			set X=dtlarr(DDATE,N)
			//set principal amount
			if ($P(X,"|",1)="P")!($P(X,"|",1)="P+I") set $P(XLN07(PER),"|",1)=$P(XLN07(PER),"|",1)+$P(X,"|",3) quit 
			//set interest amount
			if $P(X,"|",1)="I" set $P(XLN07(PER),"|",2)=$P(XLN07(PER),"|",2)+$P(X,"|",3) quit 
			//set escrow amount
			if $P(X,"|",1)["ESC" set $P(XLN07(PER),"|",3)=$P(XLN07(PER),"|",3)+$P(X,"|",3) quit 
			//else set fees amount
			set $P(XLN07(PER),"|",4)=$P(XLN07(PER),"|",4)+$P(X,"|",3) quit 
			}
		/*
		Sum amounts and compare with the total bill
		Calculated delinquency total due for a period does not match bill record
		*/
		if $P(XLN07(PER),"|",1)+$P(XLN07(PER),"|",2)+$P(XLN07(PER),"|",3)+$P(XLN07(PER),"|",4)'=DPTO(PER) set ER=1 set RM=$$^MSG(2972)
		}
	//Build XLN07
	set PER=""
	for  set PER=$O(XLN07(PER)) quit:PER=""  do {
		set I=4*(PER-1)+1
		set $P(XLN07,"|",I)=XLN07(PER)
		}
	
	quit 
	

public AVLBAL(RecordLN ln, Number CID)	// Available balance (called by ^TTXODC)

	/*
	The function is used to calculate the Available balance
	
	ARGUMENTS: Either the Loan object must be passed in or the CID must be
		passed in.  It is an either/or requirement.  If the loan object
		has not been instantiated in the calling procedure, the CID
		will be used to create it.

	 . 	ln	Loan Account		/TYP=RecordLN/REQ=Y/N
	 .	CID	Customer Account 	/TYP=N/REQ=Y/N

	 RETURNS: 
	 .	AVLBAL  Available Balance	/TYP=$
	
	 EXAMPLE:  do AVLBAL^LNCO(.ln,)
		   do AVLBAL^LNCO(,CID)

	*/
	

	if 'ln.exists() do LNAVL1(CID) quit
	do LNAVLBAL(.ln)
	quit
	
LNAVL1(Number CID)

	type RecordLN ln=Db.getRecord("LN","CID")
	do LNAVLBAL(.ln)

	quit

LNAVLBAL(RecordLN ln)
	
	type public Boolean %STFPLAY
	type public Number AVLBAL
	
	type Date XDAT
	type Number ACCUM,CID,HLDAMT
	
	set XDAT=999999
	
	// 0 if overdue and ddra is defined
	if ('ln.dist1nd.isNull()),(('ln.ddra.isNull()) & ((ln.ddra + ln.dist1nd) '> %SystemDate)) set AVLBAL=0 quit
	
	if 'ln.mdt.isNull() set XDAT=ln.mdt
	if 'ln.clmd.isNull(),(ln.clmd<XDAT) set XDAT=ln.clmd
	
	// 0 if loan or credit limit have matured
	// 04/03/09 Changed if XDAT'>%SystemDate to XDAT<%SystemDate
	
	if XDAT<%SystemDate set AVLBAL=0 quit
	
	if ln.stat=4 set AVLBAL=0 quit 
	// Consider interest billed/unpaid
	set ACCUM=0
	if ln.sibf do {
		if ln.cuin>0 set ACCUM=ACCUM+ln.cuin
		if ln.unin>0 set ACCUM=ACCUM+ln.unin
		}
	
	// Consider late charges
	if ln.raclc set ACCUM=ACCUM+ln.lchg
	
	// Consider loan fees
	if ln.raclf set ACCUM=ACCUM+$$XLN09EX^LNCDI(ln.cid,21)
	
	// Check for permanent holds
	set HLDAMT=0	      
	if ln.phld set HLDAMT=$$^UHLD(ln.cid,ln.balcmp,ln.crcd)

	set AVLBAL=ln.udbal-ln.chkhld-ACCUM-ln.coa+ln.rec+ln.donrsk-$G(HLDAMT)
	
	// If withdrawal limt, consider (ln.wdlmt-tdr) instead of udbal 
	if ln.wdlmt>0 set AVLBAL=ln.wdlmt-ln.tdr-ln.chkhld-ACCUM-ln.coa+ln.rec+ln.donrsk-$G(HLDAMT)
	
	if '(%STFPLAY.get()) set AVLBAL=AVLBAL-ln.stfnet
	if (ln.refinttytd!ln.collimpr),('ln.wdlmt.isNull()) set AVLBAL=(AVLBAL-ln.crlmt-ln.wdlmt)
	
	if ln.pcidstat>0 set AVLBAL=0
	if AVLBAL<0 set AVLBAL=0
	
	quit 

	
public TSOESC(ETC) // Called by LNPTS2 to see if
	// escrow type should be prompted for.

	new N
	set TSOESC=0
	// Posting Action Control
	type RecordTRN trn=Db.getRecord("TRN","ETC")
	if trn.pac["LNPTS16"!(trn.pac["LNPTS25")!(trn.pac["LNPTS28") do {
		new ESCA
		do ESCA^LNES2(.ESCA)
		set N=""
		for  set N=$O(ESCA(N)) quit:N=""  set TSOESC=TSOESC+1
		}
	
	if TSOESC=1 do {
		set N=""
		for  set N=$O(ESCTBL(N)) quit:N=""  set UTSO("ESC")=N
		}
	quit 


public TSOESCT(ETC) // This is called by CRTQRY
	
	// Affect Escrow Remittance
	type RecordTRN trn=Db.getRecord("TRN","ETC")
		        
	set TSOESCT=trn.pcfl11
	quit 
	
public TSOREC(ETC,CID) // Called by pre-processor on miscellaneous fields TSO("RECOV") and

	/*
	   TSO("RECS") to see if recovery amount and recovery source should
	   be prompted for.

	ARGUMENTS:
		. ETC	Transaction Code	TYPE=T/REQ

		. CID	Account Number		TYPE=N/REQ

	EXAMPLE:
		do TSOREC^LNCO(trn.etc,ttx.cid)

	
	*/
	set TSOREC=0

	if 'Db.isDefined("LN",":CID") quit
	
	new BAL,BAL1
	set (BAL,BAL1)=0
	type RecordLN ln=Db.getRecord("LN","CID=:CID") 
	if ln.aruf set BAL=ln.bal-ln.udbal
	set BAL1=BAL-ln.coa+ln.rec
	type RecordTRN trn=Db.getRecord("TRN","ETC")
	// Posting Action Control
	if $E(trn.itc),BAL>BAL1,trn.pac'["LNPTS31" set TSOREC=1
	quit 
	

public TSOAOI(CID)

	/* 
	Called by pre-processor on tran code misc. field TSO("AOI")
	Returns array of add-on item values for this account.

	ARGUMENTS:

	. CID	Account Number		TYP=N/REQ

	RETURNS:

	. TSOAOI(TYP)			TYP=ARRAY	 

	EXAMPLE:
		do TSOAOI^LNCO(ttx.cid)

	*/

	type Public String TSOAOI()
	kill TSOAOI
	
	/*
	 Collate through each LNCYC* table to load each of the different 
	 add-on item types.
	*/
	
	type ResultSet rsdld=Db.select("TYP","LNCYCDLD","CID=:CID")
	while rsdld.next() do LOADTSO(rsdld.getCol("TYP"),.TSOAOI())

	type ResultSet rsins=Db.select("TYP","LNCYCINS","CID=:CID")
	while rsins.next() do LOADTSO(rsins.getCol("TYP"),.TSOAOI())

	type ResultSet rsmsc=Db.select("TYP","LNCYCMSC","CID=:CID")
	while rsmsc.next() do LOADTSO(rsmsc.getCol("TYP"),.TSOAOI())

	type ResultSet rspts=Db.select("TYP","LNCYCPTS","CID=:CID")
	while rspts.next() do LOADTSO(rspts.getCol("TYP"),.TSOAOI())

	quit

LOADTSO(String TYP,String TSOAOI())

	type RecordLNAOT lnaot=Db.getRecord("LNAOT","TYP=:TYP")
	set TSOAOI(TYP)=lnaot.desc_"|"_lnaot.bdt_"|"_lnaot.edt
	quit 
	

public TSOPE(CID) 
	
	/*
	Called by pre-processor on tran code misc. field TSO("PE").
	Returns array of payment elements from bill file.
	ARGUMENTS:

	. CID	Account Number		TYPE=N/REQ

	EXAMPLE:
		do TSOPE^LNCO(ttx.cid)

	*/
 
	new B,FEETYP,I,LFEE,P,TRTYPE,X,lnkfee
	kill PE
	
	type ResultSet rs=Db.select("SCHSEQ","LN","CID=:CID")
	if rs.isEmpty() quit
	while rs.next() set SCHSEQ=rs.getCol(1)
	do LNKFEE^LNBLDE(CID)

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
	set ROW=$$ELEMENT^BILFUNCS(.lnbil0)
	for I=1:1 do { quit:FEETYP=""
		set TRTYPE=0
		set FEETYP=$P(ROW,$C(9),I)
		if FEETYP="" quit
		if Db.isDefined("LNFEEP","FEETYP=:FEETYP") do {
			type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP")
			set PE(FEETYP)=lnfeep.desc
			}	
		else  if FEETYP="I"!(FEETYP="P") do {
			set TRTYPE=FEETYP
			type RecordLNTRS lntrs=Db.getRecord("LNTRS","TRTYPE")
			set PE(FEETYP)=lntrs.trdes
			}
		else  do {
			set TRTYPE=$TR(FEETYP,"123456789")
			type RecordLNTRS lntrs=Db.getRecord("LNTRS","TRTYPE")
			set PE(FEETYP)=lntrs.trdes
			}
	
		for  set LFEE=$O(lnkfee(FEETYP,LFEE)) quit:LFEE=""  do {
			type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP = :LFEE", 1)
			set PE(LFEE)=lnfeep.desc
			}
		}
	
	quit


public EBBAL(CID)	// Calculate estimated balloon balance

	/*
	The extrinsic function is used to calculate the estimated balloon balance
	
	 .	CID	Customer Account 		/TYP=N/REQ=Y
	

	 RETURNS: 
	 
	 .	EBBAL	Estimated Balloon Balance	/TYP=N
	
	 EXAMPLE: do $$EBBAL^LNCO(CID)

	*/
	
	new BAL,I,P,PAYREM,Z

	type RecordLN ln=Db.getRecord("LN","CID")
	if '$L(ln.pcm) quit ""
	set P=ln.pcm
	set BAL=ln.bal
	if ln.aruf set BAL=ln.udbal-ln.bal
	if '$D(PCM(ln.pcm)),Db.isDefined("STBLPCM","KEY=:P") do {
		type RecordSTBLPCM stblpcm=Db.getRecord("STBLPCM","KEY=:P")
		set PCM(P)=stblpcm.pcmp_"|"_stblpcm.desc
		}
	
	// Original # of payments
	set Z=ln.onp
	// Amoritization Base
	if Z'<ln.ambas quit 0
	if 'ln.dist1af quit BAL
	set I=ln.irn/(ln.dist1af*100)
	set PAYREM=1+I
	// find number of payments left (ONP-CNTCR)
	set Z=Z-ln.phld
	if PAYREM=1 quit BAL-(ln.pmtpi*Z)
	set PAYREM=$$EXP^%ZFUNC($$LNX^%ZFUNC(PAYREM)*Z)
	set PAYREM=((1-PAYREM)/I)*ln.pmtpi+(BAL*PAYREM) 
	if PAYREM<0 quit 0
	quit $$^SCARND(PAYREM,0,$G(CID))+ln.pmtpi
	

public DLCO(RecordLN ln,CID)	// Date of Last Charge-off

	/*
	The function is used to calculate the Last Charge-off
	
	ARGUMENTS: Either the Loan object must be passed in or the CID must be
		passed in.  It is an either/or requirement.  If the loan object
		has not been instantiated in the calling procedure, the CID
		will be used to create it.

	 . 	ln	Loan Object		/TYP=object
	 .	CID	Customer Account 	/TYP=N

	 RETURNS: DLCO
	
	 EXAMPLE:  do DLCO^LNCO(.ln,)
		   do DLCO^LNCO(,CID)

	*/

	set DLCO=""
	new N,H,ITC,TAMT

	// if loan obj not passed create it
	if 'ln.getPointer() do DLCO1(CID) quit
	do DLCO2(.ln)
	quit	

DLCO1(CID) // Create a loan object that will be killed upon exit from this proc

	Type RecordLN ln=Db.getRecord("LN","CID")
	do DLCO2(.ln)
	quit

DLCO2(RecordLN ln)

	if 'ln.coa quit 
	set N=""

	type ResultSet rs=Db.select("TJD,ITC,TAMT","HIST","CID=:CID")
	if rs.isEmpty() quit
	while rs.next() do { quit:DLCO'=""
		set ITC=rs.getCol(2)
		if $E(ITC)'=1 quit
		set TAMT=rs.getCol(3)
		if '$L($P(TAMT,"#",10)) quit
		set DLCO=rs.getCol(1)
		}
	quit 
	

public OPUID(CID)	// user who opened loan

	type RecordHIST hist=Db.getRecord("HIST","CID,1")

	//NEW ACCOUNT
	if hist.tcmt[$$^MSG(3941) quit hist.uid
	quit ""
	

public PNTSPY(RecordLN ln,CID,ODD,PNTSPD)
	
	/*
	The function is used to calculate Points paid - prior tax year
	
	ARGUMENTS: Either the Loan object must be passed in or the CID must be
		passed in.  It is an either/or requirement.  If the loan object
		has not been instantiated in the calling procedure, the CID
		will be used to create it.

	 . 	ln	Loan Object		   /TYP=object
	 .	CID	Customer Account 	   /TYP=N
	 . 	ODD	Original disbursement dt   /TYP=DATE
	 .	PNTSPD  Points Paid by borrower	   /TYP=N

	 RETURNS: DLCO
	
	 EXAMPLE:  do $$PNTSPY^LNCO(.ln)
		   do $$PNTSPY^LNCO(CID)

	*/

	set DLCO=""
	new H,ITC,N,TAMT
	if 'ln.getPointer() quit $$PNTSPY1(CID)
	quit $$PNTSPY2(.ln)

PNTSPY1(CID)
	
	type RecordLN ln=Db.getRecord("LN","CID")
	quit $$PNTSPY2(.ln)


PNTSPY2(RecordLN ln)

	new BPTY,EPTY,ODDY,TEPPY,TAXEPREV,X
	// beginning of tax year

	set TAXB=$$BOTY^SCADAT($$BOTY^SCADAT(%SystemDate,1)-1,1)
	// end of tax year
	set TAXE=$$EOTY^SCADAT(TAXB,1)
	// Check if the disbursement date is valid.
	// If called from DATA-QWIK
	if $G(ODD),$D(PNTSPD) quit $S((ODD'<TAXB)&(ODD'>TAXE):PNTSPD,1:0)
	
	set ODDY=ln.odd
	if ((ODDY<TAXB)!(ODDY>TAXE)) quit 0
	
	quit ln.pntspd
	